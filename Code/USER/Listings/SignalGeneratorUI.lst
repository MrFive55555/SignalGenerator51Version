C51 COMPILER V9.54   SIGNALGENERATORUI                                                     06/17/2022 10:09:22 PAGE 1   


C51 COMPILER V9.54, COMPILATION OF MODULE SIGNALGENERATORUI
OBJECT MODULE PLACED IN ..\OBJ\SignalGeneratorUI.obj
COMPILER INVOKED BY: F:\Keil5\C51\BIN\C51.EXE SignalGeneratorUI.c OMF2 OPTIMIZE(8,SPEED) BROWSE INCDIR(..\USER;..\HARDWA
                    -RE\AT24C02;..\HARDWARE\MatrixKeyboard;..\HARDWARE\NixieTube;..\HARDWARE\PCF8591;..\HARDWARE\IIC) DEBUG PRINT(.\Listings\
                    -SignalGeneratorUI.lst) TABS(2) OBJECT(..\OBJ\SignalGeneratorUI.obj)

line level    source

   1          #include "SignalGeneratorUI.h"
   2          /**
   3          *ä¿¡å·å‘ç”Ÿå™¨åŠŸèƒ½æ±‡æ€»
   4          */
   5          
   6          //ä¸šåŠ¡éƒ¨åˆ†å‚æ•°:
   7          idata u8 setValue = 0;//seté”®å€¼
   8          idata u8 flickerChange = 1; //é—ªçƒåˆ‡æ¢
   9          idata leftRightValue = 1; //å·¦å³ç§»åŠ¨é”®å€¼ 0å·¦ 1å³
  10          idata u8 moveKeyOn = 0; //æ˜¯å¦åœ¨å‚æ•°çš„é€‰æ‹©ä¸‹æŒ‰äº†ç§»åŠ¨é”®
  11          idata u8 errorFlag = 0; //é”™è¯¯æ ‡å¿—
  12          idata char tubeOff = -1; //æ•°ç ç®¡æ˜¾ç¤ºç­çš„ä½ç½®
  13          idata u8 dotOn = 0; //å¼€å¯æ˜¾ç¤ºå°æ•°ç‚¹
  14          //äºŒç»´æ•°ç»„å‚¨å­˜æ•°å€¼ idataé—´æ¥å¯»å€ ç›´æ¥å¯»å€åªæœ‰128byte ä¸å¤Ÿç”¨
  15          idata u16 number[4][4]={0}; ///0TF 1TA 2RF 3RD qian shi bai ge
  16          //ç”±æ­¤å¼•å‘ä¸€ä¸ªæƒ³æ³•ï¼šstep==å½“å‰æ‰€é€‰æ‹©çš„æ³¢å½¢å’Œå‚æ•°
  17          idata u8 step = 2; //æ“ä½œæ­¥æ•° 0TF 1TA 2RF 3RD
  18          data u8 index = 0; //nixieTubeFormatçš„æ•°ç»„ä¸‹æ ‡
  19          data u8 nixieTubeFormat[8]={0,0,0,10,10,10,0,0};//æ•°ç ç®¡æ ¼å¼åŒ–æ˜¾ç¤ºä¿¡æ¯ æ§åˆ¶æ®µé€‰ä¿¡æ¯ *ä¸šåŠ
             -¡çš„æ ¸å¿ƒ*
  20          data u16 errorTimeCount = 0; //é”™è¯¯æ˜¾ç¤ºæ—¶é—´
  21          data u16 flickerTimeCount = 0;//é—ªçƒè®¡æ—¶å€¼
  22          data u8 tubeIndex = 0;
  23          data u16 showCount = 0;
  24          
  25          //ç®—æ³•éƒ¨åˆ†å‚æ•°:
  26          data u16 voltage = 0; //ç”µå‹
  27          data int changeVoltage = 0;//å˜åŒ–çš„ç”µå‹
  28          data u16 period = 0;//ä¸€ä¸ªé‡‡æ ·ç‚¹çš„å‘¨æœŸ
  29          data u8 samplingVoltage = 0; //æ¯ä¸€ä»½é‡‡æ ·ç”µå‹
  30          data u8 rise = 0; //ä¸Šå‡æˆ–è€…ä¸‹é™
  31          data u16 highPeriod = 0;//é«˜ç”µå¹³å ç”¨æ—¶é—´
  32          data u16 lowPeriod = 0;//ä½ç”µå¹³å ç”¨æ—¶é—´
  33          /**
  34          *ä¿¡å·å‘ç”Ÿå™¨ ä¸šåŠ¡ä»£ç éƒ¨åˆ†:
  35          */
  36          //é”®ç›˜æ‰«æ
  37          void keyboard(){
  38   1        u8 key;
  39   1        key = getMatrixKey();
  40   1        if(key==12){ //è®¾ç½®
  41   2          //å…³é—­æ³¢å½¢è¾“å‡º
  42   2          IIC_Stop();
  43   2          TR0 = 0;
  44   2          set();
  45   2        }else if((setValue&&(key>=13&&key<=15))||setValue==0){ //è®¾ç½®ä¹‹ä¸‹çš„åŠŸèƒ½
  46   2          switch(key){
  47   3            case 13:IIC_Stop();TR0 = 0;selectWave();break;
  48   3            case 14:IIC_Stop();TR0 = 0;selectParameter();break;
  49   3            case 15:IIC_Stop();TR0 = 0;confirm();break;
  50   3          }
  51   2        }else if((key==10||key==11)&&moveKeyOn&&setValue){ //å·¦å³é”®
  52   2          moveKey(key);
C51 COMPILER V9.54   SIGNALGENERATORUI                                                     06/17/2022 10:09:22 PAGE 2   

  53   2        }else if((index>=4&&index<=7)&&(key>=0&&key<=9)){ //è¾“å…¥æ•°å­—
  54   2          //ç›´æ¥å°†é”®ç›˜å€¼ä¼ å…¥inputnumberRFå‡½æ•°å½“æ•°å­—ä½¿ç”¨
  55   2          inputNumber(key);
  56   2        }
  57   1        //1sé”™è¯¯æ˜¾ç¤º
  58   1        if(errorTimeCount>=5000){
  59   2          errorTimeCount = 0;
  60   2          errorFlag = 0; //æ¸…é™¤é”™è¯¯æ ‡å¿—
  61   2        }
  62   1      }
  63          
  64          //ç§»åŠ¨é”®ç›˜ 
  65          void moveKey(u8 key){
  66   1        //ä¸‰è§’æ³¢å’ŒçŸ©å½¢æ³¢çš„å ç©ºæ¯”éƒ¨åˆ†ä¸¤æ ¼ç§»åŠ¨
  67   1        if(step==0||step==1||step==3){
  68   2          //å‰ä¸¤ä½æ˜¾ç¤ºæ¸…é›¶
  69   2          nixieTubeFormat[4] = 10;
  70   2          nixieTubeFormat[5] = 10;
  71   2          //ç§»åŠ¨é”®å€¼
  72   2          if(key==10) leftRightValue--; //å·¦ç§»
  73   2          else leftRightValue++; //å³ç§»
  74   2          //å·¦è¾¹å†æŒ‰ å›åˆ°å³è¾¹
  75   2          if(leftRightValue<=-1) leftRightValue = 1;
  76   2          //å³è¾¹å†æŒ‰ å›åˆ°å·¦è¾¹
  77   2          else if(leftRightValue>=2) leftRightValue = 0;
  78   2          //æ•°ç»„ä¸‹æ ‡æ›´æ”¹
  79   2          index = leftRightValue+6;
  80   2        }else{
  81   2          //çŸ©å½¢æ³¢é¢‘ç‡å››æ ¼ç§»åŠ¨
  82   2          if(key==10) leftRightValue--;//å·¦ç§»
  83   2          else leftRightValue++; //å³ç§» 
  84   2          //å·¦è¾¹å†æŒ‰ å›åˆ°å³è¾¹
  85   2          if(leftRightValue<=-1) leftRightValue = 3;
  86   2          //å³è¾¹å†æŒ‰ å›åˆ°å·¦è¾¹
  87   2          else if(leftRightValue>=4) leftRightValue = 0;
  88   2          //æ•°ç»„ä¸‹æ ‡æ›´æ”¹
  89   2          index = leftRightValue+4;
  90   2        }
  91   1      }
  92          
  93          //è®¾ç½® 
  94          void set(){
  95   1        //æŒ‰ä¸‹è®¾ç½®é”®çš„é”®å€¼åè½¬
  96   1        setValue = ~setValue;
  97   1        index = 0;
  98   1        tubeOff = -1;
  99   1        if(setValue){
 100   2          //æ˜¾ç¤ºâ€œSâ€
 101   2          nixieTubeFormat[0]=5;
 102   2        }else{
 103   2          //æ˜¾ç¤ºâ€œOâ€
 104   2          nixieTubeFormat[0]=0;
 105   2        }
 106   1      }
 107          
 108          //é€‰æ‹©æ³¢å½¢
 109          void selectWave(){
 110   1        //æŒ‰ä¸‹é€‰æ‹©æ³¢å½¢å stepåˆ‡æ¢
 111   1        if(step>=2) step = 0;
 112   1        else step = 2;
 113   1        //å°æ•°ç‚¹æ˜¾ç¤ºé»˜è®¤æ¸…é›¶
 114   1        dotOn = 0;
C51 COMPILER V9.54   SIGNALGENERATORUI                                                     06/17/2022 10:09:22 PAGE 3   

 115   1        //æ•°ç»„ä¸‹æ ‡èµ‹å€¼ä¸º1
 116   1        index = 1;
 117   1        //æ¯æ¬¡æŒ‰ä¸‹é€‰æ‹©æ¢æ³¢å½¢å å‚æ•°å§‹ç»ˆæ˜¾ç¤ºâ€œFâ€å¼€å§‹
 118   1        nixieTubeFormat[index+1] = 11;
 119   1        //å¼€å¯ç§»åŠ¨
 120   1        moveKeyOn = 1;
 121   1        //ä¿®æ”¹æ•°ç ç®¡æ˜¾ç¤ºæ–‡æœ¬
 122   1        //é€‰æ‹©çŸ©å½¢æ³¢ æ˜¾ç¤º2è¡¨ç¤º
 123   1        if(step) nixieTubeFormat[index]=step;
 124   1        //é€‰æ‹©ä¸‰è§’æ³¢ æ˜¾ç¤º1è¡¨ç¤º
 125   1        else nixieTubeFormat[index]=step+1;
 126   1        recoverNumber();
 127   1      }
 128          
 129          //é€‰æ‹©å‚æ•°
 130          void selectParameter(){
 131   1        //å°æ•°ç‚¹æ˜¾ç¤ºé»˜è®¤æ¸…é›¶
 132   1        dotOn = 0;
 133   1        //æ•°ç»„ä¸‹æ ‡èµ‹å€¼ä¸º2
 134   1        index = 2;
 135   1        //ç§»åŠ¨é”®å¼€å¯æ¿€æ´»
 136   1        moveKeyOn = 1;
 137   1        //ä¿®æ”¹æ•°ç ç®¡æ˜¾ç¤ºæ–‡æœ¬
 138   1        if(step>=2){
 139   2          step++;
 140   2          if(step==4) step = 2;
 141   2          //æ˜¾ç¤ºâ€œdâ€
 142   2          if(step==3) nixieTubeFormat[index]=step+10;
 143   2          //æ˜¾ç¤ºâ€œFâ€
 144   2          else nixieTubeFormat[index]=step+9;
 145   2        }else{
 146   2          //æ˜¾ç¤ºâ€œAâ€
 147   2          step++;
 148   2          step%=2;
 149   2          if(step){ 
 150   3            nixieTubeFormat[index]=step+11; 
 151   3            dotOn = 1;
 152   3          }
 153   2          //æ˜¾ç¤ºâ€œFâ€ 
 154   2          else nixieTubeFormat[index]=step+11;
 155   2          
 156   2        }
 157   1        recoverNumber();
 158   1      }
 159          
 160          //åˆ‡æ¢æ³¢å½¢å’Œå‚æ•°æ—¶ï¼Œæ˜¾ç¤ºå„è‡ªçš„æ•°å­—
 161          void recoverNumber(){
 162   1        u8 i;
 163   1        switch(step){
 164   2          case 0:
 165   2          case 1:
 166   2          case 3:
 167   2          nixieTubeFormat[4] = 10;
 168   2          nixieTubeFormat[5] = 10;
 169   2          nixieTubeFormat[6] = number[step][0];
 170   2          nixieTubeFormat[7] = number[step][1];break;
 171   2          case 2:for(i=0;i<4;i++) nixieTubeFormat[i+4] = number[step][i];break;
 172   2        }
 173   1      }
 174          
 175          //è¾“å…¥æ•°å­—
 176          void inputNumber(u8 key){
C51 COMPILER V9.54   SIGNALGENERATORUI                                                     06/17/2022 10:09:22 PAGE 4   

 177   1        //step 0TF 1TR 2RF 3RD
 178   1        number[step][leftRightValue] = key;
 179   1        nixieTubeFormat[index] = key;
 180   1      }
 181          
 182          //ç¡®è®¤
 183          void confirm(){
 184   1        //é”™è¯¯æ£€æµ‹
 185   1        u8 checkPass;
 186   1        checkPass = isError();
 187   1        if(checkPass){ //æ²¡é”™
 188   2          //æ•°ç»„ä¸‹æ ‡ç½®ä¸º0
 189   2          index = 0;
 190   2          tubeOff = -1;
 191   2          //æ¸…é›¶è®¾ç½®é”®å€¼å’Œå…³é—­ç§»åŠ¨é”®æ¿€æ´»
 192   2          if(setValue) setValue = 0;
 193   2          if(moveKeyOn) moveKeyOn = 0;
 194   2          //æ˜¾ç¤ºâ€œOâ€
 195   2          nixieTubeFormat[0]=0;
 196   2          //æœ€åå†™å…¥æ•°æ®
 197   2          saveData();
 198   2          writeData();
 199   2        }else{ //é”™è¯¯ æ˜¾ç¤º1sçš„é”™è¯¯æç¤ºä¿¡æ¯
 200   2          errorFlag = 1;
 201   2        }
 202   1      }
 203          
 204          //æ˜¾ç¤ºæ•°ç ç®¡
 205          void showTube(){
 206   1        weixuan(tubeIndex);
 207   1        if(tubeIndex==tubeOff&&!errorFlag) duanxuan(14,0); //ä¸æ˜¾ç¤º (å®é™…ä¸Š,ä¼ å…¥å…¨ç­çš„å‚æ•°)
 208   1        else if(dotOn&&tubeIndex==6&&!errorFlag) duanxuan(nixieTubeFormat[tubeIndex],1); //å¹…å€¼æŒ¡ æ˜¾ç¤ºå°æ•°
             -ç‚¹
 209   1        else if(errorFlag) duanxuan(tubeIndex,2); //é”™è¯¯æ˜¾ç¤º
 210   1        else duanxuan(nixieTubeFormat[tubeIndex],0); //æ­£å¸¸æ˜¾ç¤º
 211   1        tubeIndex++;
 212   1        tubeIndex%=8;
 213   1      }
 214          
 215          //æ£€æŸ¥æ˜¯å¦é”™è¯¯è¾“å…¥
 216          u8 isError(){
 217   1        u8 checkPass1 = 0; //0å‡ºé”™ 1æ— é”™
 218   1        u8 checkPass2 = 0; 
 219   1        //åˆ†ä¸‰è§’æ³¢å’ŒçŸ©å½¢æ³¢æ¥æ£€æŸ¥
 220   1        if(step<=1){
 221   2          //ä¸‰è§’æ³¢é¢‘ç‡ èŒƒå›´ f = 0-20hz
 222   2          if(number[0][0]>=0&&number[0][0]<5) checkPass1 = 1;
 223   2          else if(number[0][0]==5&&number[0][1]==0) checkPass1 = 1;
 224   2          else checkPass1 = 0;
 225   2          //å¹…å€¼ vpp = 1-5v
 226   2          if(number[1][0]>=1&&number[1][0]<5) checkPass2 = 1;
 227   2          else if(number[1][0]==5&&number[1][1]==0) checkPass2 = 1;
 228   2          else checkPass2 = 0;
 229   2        }else{
 230   2          //çŸ©å½¢æ³¢é¢‘ç‡ f = 20-1000hz
 231   2          if(number[2][0]<1) checkPass1 = 1;
 232   2          else if(number[2][0]==1&&number[2][1]==0&&number[2][2]==0&&number[2][3]==0) checkPass1 = 1;
 233   2          else if(number[2][0]==0&&number[2][1]==0&&number[2][2]<2) checkPass1 = 0;
 234   2          else checkPass1 = 0;
 235   2          //å ç©ºæ¯”
 236   2          if(number[3][0]>=2&&number[3][0]<8) checkPass2 = 1;
 237   2          else if(number[3][0]==8&&number[3][1]==0) checkPass2 = 1;
C51 COMPILER V9.54   SIGNALGENERATORUI                                                     06/17/2022 10:09:22 PAGE 5   

 238   2          else checkPass2 = 0;
 239   2        }
 240   1        return checkPass1&checkPass2;
 241   1      }
 242          
 243          //å®šæ—¶å™¨åˆå§‹åŒ–
 244          void TimerInit(){
 245   1        //å®šæ—¶å™¨1 16ä½è‡ªåŠ¨é‡è½½ å®šæ—¶å™¨0 8ä½
 246   1        TMOD = 0x21;
 247   1        //200usæº¢å‡º
 248   1        TH1 = 56;
 249   1        TL1 = 56;
 250   1        EA = 1;
 251   1        ET1 = 1;
 252   1        TR1 = 1;
 253   1        ET0 = 1;
 254   1        TR0 = 0;
 255   1      }
 256          
 257          //æš‚æ—¶ä¸è¦åŠ using ä¼šå¯¼è‡´ç¨‹åºé”™è¯¯ å¦‚ä¸­æ–­æ— æ³•ä½¿ç”¨
 258          //é—ªçƒä¸­æ–­å‡½æ•°
 259          void interruptFlicker() interrupt 3 {
 260   1        showCount++;
 261   1        flickerTimeCount++;
 262   1        if(showCount>=12){
 263   2          showCount = 0;
 264   2          showTube();
 265   2        }
 266   1        //300msæº¢å‡º
 267   1        if(flickerTimeCount>=1500&&index!=0){
 268   2          flickerTimeCount = 0;
 269   2          //å†³å®šå“ªä¸€ä½æ˜¾ç¤ºç­ ä¸å†æ›´æ”¹æ•°ç»„ä¸‹æ ‡ åŸå€¼å¾—ä»¥ä¿ç•™
 270   2          if(flickerChange) tubeOff=index;
 271   2          //æ¸…é›¶æ˜¾ç¤ºç­çš„ä½
 272   2          else tubeOff = -1;
 273   2          flickerChange = !flickerChange; //ä»¿çœŸbug è¿™é‡Œä¸èƒ½ç”¨~å–å è¦ç”¨!
 274   2        }
 275   1        if(errorFlag) errorTimeCount++;
 276   1      }
 277          
 278          //å†™å…¥æ•°æ®
 279          void writeData(){
 280   1        adjustFreq();
 281   1      }
 282          //å»¶æ—¶5ms
 283          void Delay5ms()   //@12.000MHz
 284          {
 285   1        unsigned char i, j;
 286   1      
 287   1        i = 10;
 288   1        j = 183;
 289   1        do
 290   1        {
 291   2          while (--j);
 292   2        } while (--i);
 293   1      }
 294          
 295          //ä¿å­˜æ•°æ®
 296          void saveData(){
 297   1        //å†™å…¥æ•°æ®éœ€è¦è‡³å°‘5mså»¶æ—¶ ç¡®ä¿å†™å…¥å®Œæ¯•
 298   1        //ä¿å­˜æ•°ç ç®¡æ˜¾ç¤ºçš„å‰ä¸‰ä½ä¿¡æ¯
 299   1        u8 i,j,k;
C51 COMPILER V9.54   SIGNALGENERATORUI                                                     06/17/2022 10:09:22 PAGE 6   

 300   1        for(i=0;i<4;i++){
 301   2          if(i==3) AT24C02WriteByte(i,step); //3
 302   2          else AT24C02WriteByte(i,nixieTubeFormat[i]); //0 1 2
 303   2            //ä¿å­˜å½“å‰stepä¿¡æ¯
 304   2          Delay5ms();
 305   2        }
 306   1        //ä¿å­˜æ•°å€¼ä¿¡æ¯
 307   1        k = 4;
 308   1        for(i=0;i<4;i++){
 309   2          for(j=0;j<4;j++){
 310   3            /*4 5 6 7
 311   3            * 8 9 10 11
 312   3            * 12 13 14 15
 313   3            * 16 17 18 19
 314   3            */
 315   3            AT24C02WriteByte(k,number[i][j]);
 316   3            Delay5ms();
 317   3            k++;
 318   3          }
 319   2        }
 320   1      }
 321          
 322          //å¼€æœºæ¢å¤æ•°æ®
 323          void recoverData(){
 324   1        //æ¢å¤æ•°ç ç®¡æ•°æ®
 325   1        u8 i,j,k;
 326   1        for(i=0;i<4;i++){
 327   2          if(i==3) step = AT24C02ReadByte(i); //3
 328   2          else nixieTubeFormat[i] = AT24C02ReadByte(i); //0 1 2
 329   2        }
 330   1        //æ¢å¤æ•°å€¼æ•°æ®
 331   1        k = 4;
 332   1        for(i=0;i<4;i++){
 333   2          for(j=0;j<4;j++){
 334   3            /*4 5 6 7
 335   3            * 8 9 10 11
 336   3            * 12 13 14 15
 337   3            * 16 17 18 19
 338   3            */
 339   3            number[i][j] = AT24C02ReadByte(k);
 340   3            k++;
 341   3          }
 342   2        }
 343   1      }
 344          /**
 345          *ç®—æ³•éƒ¨åˆ†:
 346          */
 347          void interruptFreq() interrupt 1{
 348   1        /*è°ƒç”¨æ­¤ä¸­æ–­æ—¶ å‘ç°æ•°ç ç®¡æ— æ³•æ˜¾ç¤º çŒœæµ‹å¦‚ä¸‹*/
 349   1        //å†™å…¥æ•°å­—é‡
 350   1        //digitalToAnlog(255);
 351   1        //çŒœæµ‹:periodè®¡ç®—å€¼æœ‰é—®é¢˜ digitalToAnlogä¹Ÿæœ‰é—®é¢˜ æœ€ç»ˆå‘ç°periodæœ‰é—®é¢˜ periodå¯èƒ½è®¡ç
             -®—ä¸º0 å¯¼è‡´æ— é™å¡åœ¨ä¸­æ–­é‡Œ
 352   1        //æœ€åå‘ç°ä»¥ä¸ŠçŒœæƒ³éƒ½é”™äº† çœŸæ­£çš„é”™è¯¯åŸå›  åœ¨äºä¸­æ–­ä½¿ç”¨äº†using xå¯¼è‡´ç¨‹åºå¡æ­»
 353   1        //ä½†æœ€åå‘ç° é¢‘ç‡å¿«äº† ä¸­æ–­å…¨éƒ¨ç”¨äºå†™å…¥æ•°æ®æ—¶ æ²¡æ—¶é—´å»æ‰§è¡Œæ•°ç ç®¡æ˜¾ç¤º
 354   1        //åªèƒ½åœ¨ä¸­æ–­å‡½æ•°ä¸­å†™å…¥æ•°æ®äº† å› ä¸ºåªæœ‰å®ƒåœ¨å¾ªç¯
 355   1        //ä¸ŠåŠå‘¨æœŸ å•è°ƒé€’å¢
 356   1        EA = 0;
 357   1        if(step>=2){
 358   2          rise = !rise;
 359   2          if(rise){
 360   3            TH0 = highPeriod>>8;
C51 COMPILER V9.54   SIGNALGENERATORUI                                                     06/17/2022 10:09:22 PAGE 7   

 361   3            TL0 = highPeriod;
 362   3            P1_6 = 1;
 363   3          }else{
 364   3            TH0 = lowPeriod>>8;
 365   3            TL0 = lowPeriod;
 366   3            P1_6 = 0;
 367   3          }
 368   2        }else{
 369   2          //æœ€å¤š44hzä¸‰è§’æ³¢äº† å› ä¸ºPCF8591å’Œå•ç‰‡æœºçš„è¿è¡Œé€Ÿåº¦æé™äº† æ²¡é‚£ä¹ˆå¿«äº†
 370   2          //å¹¶ä¸”æˆ‘ä½¿ç”¨äº†è¾ƒå¤šçš„å‡½æ•°å°è£… å¯¹æ€§èƒ½æœ‰ä¸€å®šæŸå¤± ä½†å‡½æ•°å°è£…æ€»å½’æ˜¯å¥½çš„
 371   2          TH0 = period>>8;
 372   2          TL0 = period;
 373   2          if(rise){
 374   3            changeVoltage+=samplingVoltage;
 375   3            if(changeVoltage>=voltage){ 
 376   4              changeVoltage = voltage;
 377   4              rise = !rise;
 378   4            }
 379   3          }else{
 380   3            changeVoltage-=samplingVoltage; 
 381   3            //ä»¥ä¸‹è¯­å¥å°±æ²¡æ‰§è¡Œ æ‰€ä»¥å¯¼è‡´ä¸Šå‡éƒ¨åˆ†æ‰§è¡Œä¸äº† changeVoltage å‡å»0æ²¡å€¼äº† å¾ˆå¥‡æ€
             -ª
 382   3            //å°†changeVoltageæ”¹æˆæœ‰ç¬¦å·çš„æ•°å­—å³å¯è§£å†³é—®é¢˜
 383   3            if(changeVoltage<=0){
 384   4              changeVoltage = 0;
 385   4              rise = !rise;
 386   4            }       
 387   3          }
 388   2          //ä¸­æ–­å‘é€æ•°æ®ä¿¡å·å³å¯ ä¸å†å¤šæ¬¡è¿æ¥ æµªè´¹æ—¶é—´
 389   2          IIC_SendByte(changeVoltage);
 390   2          IIC_SendAck(1);
 391   2        }
 392   1        EA = 1;
 393   1      
 394   1      }
 395          
 396          //è°ƒèŠ‚é¢‘ç‡
 397          void adjustFreq(){ 
 398   1          /**F=10hz-50hz T=100000us-20000us
 399   1          *ä¸‰è§’æ³¢ é‡‡æ ·ç‚¹16ä¸ªä¸€å‘¨æœŸ æ‰€ä»¥T/16; T=6250us-1250us; 1hzå‘¨æœŸ12500us
 400   1          *ç”µå‹ä¹Ÿè¦åˆ†æˆ32ä»½
 401   1          */
 402   1        //ä¸‰è§’æ³¢
 403   1        if(step<=1){
 404   2          float freq;
 405   2          freq = (float)(number[0][0]*10+number[0][1]);
 406   2          freq = 31250/freq;
 407   2          //å››èˆäº”å…¥
 408   2          if((freq-(u16)freq)>=0.5) period = (u16)freq+1;
 409   2          else period = (u16)freq; //å¾—åˆ°ä¸€ä¸ªé‡‡æ ·ç‚¹çš„å‘¨æœŸ
 410   2          //èµ‹å€¼å¹¶å¯åŠ¨å®šæ—¶å™¨1
 411   2          adjustVoltage(); //å¾—åˆ°ç”µå‹æ•°å­—é‡
 412   2        }else{ //çŸ©å½¢æ³¢
 413   2          /**
 414   2          *F=20HZ-1000HZ T=50000us-1000us
 415   2          */
 416   2          float freq;
 417   2          freq = (float)(number[2][0]*1000+number[2][1]*100+number[2][2]*10+number[2][3]);
 418   2          freq = (float)1000000/freq;
 419   2          //å››èˆäº”å…¥
 420   2          if((freq-(u16)freq)>=0.5) period = (u16)freq+1;
 421   2          else period = (u16)freq; //ä¸€ä¸ªçŸ©å½¢æ³¢çš„å‘¨æœŸ é«˜ä½ç”µå¹³ä¸ºä¸€å‘¨æœŸ
C51 COMPILER V9.54   SIGNALGENERATORUI                                                     06/17/2022 10:09:22 PAGE 8   

 422   2          adjustDutyCycle();
 423   2        }
 424   1      }
 425          //è°ƒèŠ‚ç”µå‹
 426          void adjustVoltage(){ //1.0v-5.0v
 427   1        //æ•°æ®å¤„ç† 
 428   1        float temp;
 429   1        temp =(float)(number[1][0]*10+number[1][1])/10;
 430   1        temp = temp*255/5;
 431   1        //å››èˆäº”å…¥
 432   1        if((temp-(u16)temp)>=0.5) voltage = (u16)temp+1;
 433   1        else voltage = (u16)temp;
 434   1        temp = temp/16;  //æ¯ä¸€ä»½é‡‡æ ·æ•°å­—é‡ 
 435   1        if((temp-(u16)temp)>=0.5) samplingVoltage = (u16)temp+1;
 436   1        else samplingVoltage = (u16)temp;
 437   1        period = 65536-period;
 438   1        TH0 = period>>8;
 439   1        TL0 = period;
 440   1        rise = 1;//ä¸Šå‡
 441   1        /**
 442   1        *é—®é¢˜è§£å†³çš„å…³é”®ï¼šä¸è¦å¤šæ¬¡è¿æ¥ è¿æ¥è®¾å¤‡æ‰€è€—è´¹çš„æ—¶é—´æ¯”è¾ƒé•¿
 443   1        *æ‰€ä»¥åªå‘é€ä¸€æ¬¡è¿æ¥ä¿¡å· å…¶ä½™åªè¦å‘é€æ•°æ®ä¿¡å·å³å¯
 444   1        *ç©¶å…¶åŸå› å¯¹IICä¸å¤Ÿäº†è§£ çµæ„Ÿæ¥æºï¼šç®¡ç¼è€å¸ˆ
 445   1        */
 446   1        //ä¸»æœºå‘ä»æœºå†™å…¥åœ°å€
 447   1        IIC_Start();            
 448   1        IIC_SendByte(0x90);
 449   1        IIC_ReceiveAck();
 450   1        //é€‰æ‹©æ¨¡æ‹Ÿè¾“å‡º      
 451   1        IIC_SendByte(0x40);
 452   1        IIC_ReceiveAck();
 453   1        //ä¸­æ–­é‡Œå‘é€æ•°æ®
 454   1        TR0 = 1;
 455   1      }
 456          
 457          //è°ƒèŠ‚å ç©ºæ¯”
 458          void adjustDutyCycle(){
 459   1        //20%-80%
 460   1        float temp;
 461   1        //u16ç±»å‹è½¬æ¢ä½floatå‚ä¸æµ®ç‚¹è¿ç®—
 462   1        temp = (float)(number[3][0]*10+number[3][1])/100;
 463   1        //æ±‚å‡ºé«˜ç”µå¹³å ç”¨æ—¶é—´
 464   1        temp = temp*(float)period;
 465   1        if((temp-(u16)temp)>=0.5)  highPeriod = (u16)temp+1;
 466   1        else highPeriod = (u16)temp;
 467   1        lowPeriod = period - highPeriod;
 468   1        //é¢‘ç‡è¡¥å¿
 469   1        highPeriod = 65536-highPeriod+60;
 470   1        lowPeriod = 65536-lowPeriod+60;
 471   1        //èµ‹å€¼åˆ«åŠ ä¸Šç®—æœ¯è¿ç®— å¦åˆ™ä¼šå¯¼è‡´å®šæ—¶å™¨æ—¶é—´ä¸å‡†ç¡®
 472   1        TH0 = highPeriod>>8;
 473   1        TL0 = highPeriod;
 474   1        rise = 1;
 475   1        TR0 = 1;
 476   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   2361    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
C51 COMPILER V9.54   SIGNALGENERATORUI                                                     06/17/2022 10:09:22 PAGE 9   

   DATA SIZE        =     28      20
   IDATA SIZE       =     41    ----
   BIT SIZE         =   ----    ----
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
